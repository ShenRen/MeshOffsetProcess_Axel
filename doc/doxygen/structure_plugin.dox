/** \page structure_plugin The structure of a plugin

 Axel is a cross platform sofware composed of a main application and several plugins. In this article, we describe the structure of the code required for an  Axel plugin. A plugin consists of a set of classes and some configurations files. Let's see an example of a plugin generated by the axel-plugin project wizard (named "MyPlugin") with data (named "param") and a process (named "offset"). I'll explain (for each of the  following classes) the important things to respect if you want to create your own plugin :

  - MyPluginDefaultProcess
  - MyPluginDefaultProcessDialog
  - MyPluginDefaultData
  - MyPluginDefaultDataDialog
  - MyPluginDefaultDataReader
  - MyPluginDefaultDataWriter
  - MyPluginDefaultDataConverter
  - MyPluginDefaultDataCreatorProcessDialog
  - MyPluginPlugin
  - MyPluginPluginExport
  - CMakeList

Before analyzing in detail each class, we first have a look at the taxonomy of the plugin :

 -# MyPluginDefaultProcess and MyPluginDefaultProcessDialog correspond to the \b process named Default. Their generic names are <plugin_project_name><process_name>Process and <plugin_project_name><process_name>ProcessDialog.
 -# MyPluginDefaultData, MyPluginDefaultDataDialog, MyPluginDefaultDataReader, MyPluginDefaultDataWriter, MyPluginDefaultDataConverter, MyPluginDefaultDataCreatorProcessDialog form the \b data named DefaultData. Their generic names are <plugin_project_name><data_name>Data, <plugin_project_name><data_name>DataDialog, etc.
 -# MyPluginPlugin and MyPluginPluginExport files are for the \b plugin configuration and initialisation. Their generic names are <plugin_project_name>Plugin and <plugin_project_name>PluginExport.
 -# CMakeList is its generic name.

As you can see, a plugin for axel consists of a lot of classes. If the plugin config pattern is always necessary and unique, data pattern or process pattern isn't. You can create a plugin just for one or more processes and/or one ore more data. In addition, you probably already know that Axel directly depends of dtk library. Most of Axel classes inherit from one of the dtk classes. you will find more information about dtk library there.

I'll continue on this example to explain plugin classes. In this documentation, you will see how to generate a first plugin based on this example. I recommend you to follow explanations of classes with the example opened in QtCreator.

\section process_pattern  Process Pattern:

 - MyPluginDefaultProcess: this class inherits from \p dtkAbstractProcess. You will create the core of your process there. For that you need to override or implement these methods :
\code
virtual QString description (void) const; // The description of your process

virtual QString identifier (void) const; // return the name of the class : MyPluginDefaultProcess

int update (void); // use input data or parameters to create your output.
                  // This method is the core of your process

static bool registered (void); // register the process into the dtkAbstractProcessFactory

void setInput (dtkAbstractData *data, int channel); // To set you attribute input data,
// you need to override from dtkAbstractProcess all virtual method you need

dtkAbstractData *output (void);// To get you attribute output data,
// you need to override from dtkAbstractProcess all virtual method you need
\endcode 

 - MyPluginDefaultProcessDialog : this class inherits from \p axlInspectorToolInterface. You will create the GUI of your process there that you can see on Axel if you select you process from the tool inspector (see Apply a process on a selected data if you don't know what I mean by tool inspector). For that you need to implement these methods and declare a signal :
\code
int run (void); // this method is called when user click on run button in Axel.
// using widgets of GUI defined into MyPluginDefaultProcessDialog constructors,
// MyPluginDefaultProcess methods are called to set process attributes and run its update method,
// then you will use the dataInserted signal to emit new data created if existed

static bool registered (void); // register the process into the dtkAbstractProcessFactory

signals:
    void dataInserted (axlAbstractData *data); 
// Use it in run method of MyPluginDefaultProcessDialog to insert new data in Axel 
\endcode
 

\section data_patern  Data Pattern

 - MyPluginDefaultData : this class inherits from \p axlAbstractData. You will create the core of your data there. For that you need to override or implement  virtual methods of \p axlAbstractData :
\code
virtual QString description (void) const; // The description of your data

virtual QString identifier (void) const; // return the name of the class : MyPluginDefaultData

virtual QString objectType (void) const; // return the type of the class : axlAbstractData

static bool registered (void); // register the process into the dtkAbstractDataFactory
\endcode
  \note When you add a data in your plugin, you have to extend one of the abstract data class given into the abstract taxonomy of Axel data. For instance, BSpline surface data implementation given with BSplineTools plugin extend axkAbstractSurfaceBSpline directly instead of \p axlAbstractData that is more abstract. That mean you have to override all virtual method of \p axlAbstractSurfaceBSpline and its parents classes in addition.

 - MyPluginDefaultDataDialog : this class inherits from \p axlInspectorObjectInterface. You will create the GUI of your data there.that you can see on Axel if you select you process from the object inspector (see Apply a process on a selected data if you don't know what I mean by object inspector). For that you need to add all GUI elements you need as attributes. Some of there come from parents classes and other come from your specific data.
\code
    static bool registered (void); // register the process into the axlInspectorObjectFactory

public slots:
    void setData (dtkAbstractData *data); // Initialize your data attributes
    // and run the initWidget

private :
    void initWidget (void); // The most important method of the class.
// All axlAbstractData have some basic properties :

// color, opacity, size and shader. Using the data and other private method of the class,
// GUI elements are initialized.

// In addition, initialize new GUI elements you added depending of your specific data.

// Then Create all connections needed to link in real time your
// data logic representation with data graphic representation
\endcode
\note There are some signals and other private methods I didn't mentionned there, because they are already implemented. There are usefull for one part of initWidget method which will initialize \p axlAbstractData properties. Moreover, their connections  are already created to. If you create by your self and from scratch this class, you have to add them manually and as identical. In other way, if you use axel-plugin wizard, the MyPluginDefaultDataDialog  will be generated with them.

 - MyPluginDefaultDataReader : this class inherits from \p axlAbstractDataReader. If it is not necessary to create a data plugin, it permits to create data by the reading  an axl file. You will find more complements informations there. Let's see what methods you have to implements :
\code
virtual QString description (void) const; // The description of your reader

virtual QString identifier (void) const; // return the name of the class : MyPluginDefaultDataReader

virtual QStringList handled (void) const; // return list of data identifier that it can handle

static bool registered (void); // register the process into the dtkAbstractDataFactory

public:
    bool accept (const QDomNode& node); // condition of QDomNode to recognize your data type
    bool reject (const QDomNode& node); // return ! (this->accept);
    
    dtkAbstractData *read (const QDomNode& node); // If QDomNode is accepted,

// you have to use parsed informations to create you data
\endcode

 - MyPluginDefaultDataWriter : this class inherits from \p axlAbstractDataWriter. If it not necessary to create a data plugin, it permits to create an axl file from your data opened in Axel. You will find more complements informations there. Let's see what methods you have to implements :
\code
virtual QString description (void) const; // The description of your reader

virtual QString identifier (void) const; // return the name of the class : MyPluginDefaultDataWriter

virtual QStringList handled (void) const; // return list of data identifier that it can handle

static bool registered (void); // register the process into the dtkAbstractDataFactory

public:
    bool accept (dtkAbstractData *data); // return true if we can 
    // dynamic_cast<MyPluginDefaultData *> (data)
    bool reject (dtkAbstractData *data); // return ! (this->accept);

    QDomElement write (QDomDocument *doc, dtkAbstractData *data); // if the data is accepted

// you have to write data attributes into a QDomElement
\endcode

 - MyPluginDefaultDataConverter : this class inherits from \p axlAbstractDataConverter. You have already create the data, but how Axel can show your data inside the view ? It's possible because of this class. You will convert there your MyPluginDefaultData into an \p axlMesh which can be displayed inside Axel view. For that you have to implements :
\code
virtual QString description (void) const; // The description of your converter

virtual QString toType (void) const; // return the type of the output converter
// : axlMesh

virtual QStringList fromTypes (void) const; // return list of data types that your inherit

static bool registered (void); // register the process into the dtkAbstractDataFactory

public:

    axlMesh* toMesh (void); // you have to implement it 

// create a mesh from your data and use axlMesh to store it
\endcode

 - MyPluginDefaultDataCreatorProcessDialog : this class inherits from \p axlInspectorToolInterface and respect pattern of processDialog. You will create the GUI necessary to create a MyPluginDefaultData, that you can see on Axel if you select your generator from the tool inspector (see Open a data from a generator tool. if you don't know how to do. For this processDialog, you don't have to create a class MyPluginDefaultDataCreatorProcess, because the Dialog will do that for you. For that you need to implement these methods and declare a signal :
\code
int run (void); // this method is called when the user clicks on run button in Axel.
// using widgets of GUI defined into MyPluginDefaultDataCreatorProcessDialog constructors,
// MyPluginDefaultData will be created then inserted by the dataInserted signa,

static bool registered (void); // register the process into the dtkAbstractProcessFactory

signals:
    void dataInserted (axlAbstractData *data); 
// Use it in run method of MyPluginDefaultProcessDialog to insert new data in Axel 
\endcode
 

\section config_pattern  Plugin Config Pattern :

 - MyPluginPlugin: this class inherits from \p dtkPlugin. You will include all files of process pattern and data pattern. Then in the initialize method, you will call for each of them their register method. In addition, static variables will be defined to access singleton instance of used factories in your plugin :
\code
virtual QString description (void) const; // The description of your plugin

virtual QString name (void) const; // return the name of the class : plugPlugin

virtual QStringList types (void) const; // List data and process classes embedded in your plugin

virtual bool initialize (void); // call static registered method of all data and process clases
// and initialize static variables to their correspondant factory

public:
    static dtkAbstractDataFactory *dataFactSingleton;
    static dtkAbstractProcessFactory *processFactSingleton;
\endcode
\note Two other methods need to be implemented but we still not give them uses in axel-plugin. So juste implement them as you want for the moment
\code
virtual QStringList tags (void) const;

virtual bool uninitialize (void);
\endcode

 - MyPluginPluginExport : In fact, there, you have only one file plugPluginExport.h and it's not a class. This files contain some preprocessor directives that permit to you plugin to get the cross compilation on windows with static compilation. Then for each class header, you add the preprocessor value (initialized by this file). for instance :
\code
class plugPlugin : public dtkPlugin 
\endcode
becomes
\code
class PLUGPLUGIN_EXPORT plugPlugin : public dtkPlugin
\endcode
 
**/